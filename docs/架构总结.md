# GoldsrcFramework 架构总结

## 一句话概括

GoldsrcFramework 是一个通过 C++ 原生加载器启动 .NET 运行时，将 GoldSrc 引擎与 C# 托管代码连接起来的框架，允许开发者使用 C# 开发 Half-Life 模组。

## 核心架构 (四层)

```
┌─────────────────────────────────────────────────────────┐
│  GoldSrc Engine (hl_win32.exe)                          │
│  - 加载 DLL                                              │
│  - 调用导出函数                                          │
│  - 提供引擎函数                                          │
└─────────────────────────────────────────────────────────┘
                        ↓ ↑
┌─────────────────────────────────────────────────────────┐
│  原生层 (C++) - GoldsrcFramework.Loader                 │
│  - 初始化 .NET 运行时 (hostfxr)                         │
│  - 导出引擎期望的函数 (client.dll/hl.dll)              │
│  - 转发调用到托管代码                                    │
│  - 实体导出函数 (entity_exports.cpp)                    │
└─────────────────────────────────────────────────────────┘
                        ↓ ↑
┌─────────────────────────────────────────────────────────┐
│  引擎接口层 (C#) - GoldsrcFramework.Engine             │
│  - 类型定义 (edict_t, entvars_t, Vector3f)             │
│  - 接口定义 (IServerExportFuncs, IClientExportFuncs)   │
│  - 引擎函数结构 (enginefuncs_t, cl_enginefunc_t)       │
└─────────────────────────────────────────────────────────┘
                        ↓ ↑
┌─────────────────────────────────────────────────────────┐
│  框架层 (C#) - GoldsrcFramework                         │
│  - FrameworkInterop: 统一入口点                         │
│  - ServerMain/ClientMain: 管理类                        │
│  - LegacyInterop: 原版 DLL 桥接                         │
│  - FrameworkExports: 默认实现                           │
│  - EntityContext: 实体管理                              │
└─────────────────────────────────────────────────────────┘
                        ↓ ↑
┌─────────────────────────────────────────────────────────┐
│  游戏层 (C#) - GoldsrcFramework.Demo 或自定义           │
│  - 实现 IServerExportFuncs/IClientExportFuncs           │
│  - 自定义游戏逻辑                                        │
│  - 可选择性调用原版 DLL                                  │
└─────────────────────────────────────────────────────────┘
                        ↓ ↑
┌─────────────────────────────────────────────────────────┐
│  原版 DLL (libserver.dll / libclient.dll)               │
│  - 原版 Half-Life 逻辑                                   │
│  - 实体私有数据分配                                      │
└─────────────────────────────────────────────────────────┘
```

## 关键流程

### 1. 初始化流程 (服务端)

```
引擎启动
  → 加载 hl.dll (实际是 Loader)
  → Loader 初始化 .NET 运行时
  → 加载 GoldsrcFramework.dll
  → 引擎调用 GiveFnptrsToDll(enginefuncs, globals)
    → FrameworkInterop 初始化框架
    → 加载游戏程序集 (GoldsrcFramework.Demo.dll)
    → 查找实现 IServerExportFuncs 的类型
    → 初始化 LegacyServerInterop
      → 加载 libserver.dll
      → 获取原版函数表
  → 引擎调用 GetEntityAPI2(&pFunctionTable, &version)
    → ServerMain 填充函数表
    → 函数指针指向游戏实现的方法
  → 初始化完成
```

### 2. 运行时调用流程

```
引擎需要调用游戏逻辑 (例如 Spawn)
  → 通过函数表调用: pFunctionTable->Spawn(edict)
  → 函数指针指向托管方法
  → GameServerExports::Spawn(edict_t*) 或 FrameworkServerExports::Spawn(edict_t*)
    → [可选] 执行自定义逻辑
    → [可选] 调用引擎函数: ServerMain.EngineApis->pfnServerPrint(...)
    → [可选] 转发到原版: LegacyServerInterop.Spawn(edict)
      → 调用 libserver.dll 的 Spawn 函数
  → 返回结果给引擎
```

### 3. 实体分配流程

```
地图加载，发现实体 "monster_barney"
  → 引擎查找导出函数 "monster_barney"
  → 调用 Loader::monster_barney(entvars_t*)
  → entity_exports.cpp::monster_barney(entvars_t*)
    → 首次调用: InitializePrivateDataAllocators()
      → 调用 FrameworkInterop::GetPrivateDataAllocator("monster_barney")
        → EntityContext::GetLegacyEntityPrivateDataAllocator("monster_barney")
          → 从 libserver.dll 获取函数指针
          → 缓存函数指针
    → 调用缓存的函数指针
      → libserver.dll::monster_barney(entvars_t*)
        → 分配 CBarney 私有数据
        → 存储到 edict->pvPrivateData
```

## 关键技术点

### 1. UnmanagedCallersOnly

允许原生代码直接调用托管函数，无需 COM 互操作。

```csharp
[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvCdecl) })]
public static void GiveFnptrsToDll(enginefuncs_s* pengfuncsFromEngine, globalvars_t* pGlobals)
{
    // 可以被原生代码直接调用
}
```

### 2. 函数指针

使用 C# 9+ 的函数指针语法表示原生函数指针。

```csharp
public unsafe struct enginefuncs_s
{
    public delegate* unmanaged[Cdecl]<int, sbyte*, void> pfnServerPrint;
    // ...
}
```

### 3. 动态程序集加载

运行时加载游戏程序集，通过反射查找实现接口的类型。

```csharp
var serverType = gameAssembly.GetTypes()
    .FirstOrDefault(x => x.GetInterface(nameof(IServerExportFuncs)) == typeof(IServerExportFuncs));
```

### 4. 双向互操作

- **引擎 → 框架**: 通过导出函数和函数表
- **框架 → 引擎**: 通过引擎函数指针 (enginefuncs_t)
- **框架 → 原版 DLL**: 通过 P/Invoke 和函数表

## 数据流

```
┌──────────────┐
│ Engine Heap  │ ← 引擎分配的内存
│  - edict_t[] │   (edict 数组、全局变量等)
│  - globals   │
└──────────────┘
       ↓ 指针传递
┌──────────────┐
│ Managed Heap │ ← .NET 托管堆
│  - Objects   │   (游戏对象、字符串等)
│  - Strings   │
└──────────────┘
       ↓ P/Invoke
┌──────────────┐
│ Legacy Heap  │ ← 原版 DLL 堆
│  - CBaseEnt  │   (实体私有数据)
│  - Private   │
└──────────────┘
```

**共享数据**: edict_t 和 entvars_t 在引擎堆中，所有层都通过指针访问。

## 开发模式

### 完全自定义

```csharp
public unsafe class MyServerExports : IServerExportFuncs
{
    // 完全自己实现所有逻辑
    public void GameInit() { /* 自定义 */ }
    public int Spawn(edict_t* pent) { /* 自定义 */ }
    // ...
}
```

### 扩展框架默认

```csharp
public unsafe class MyServerExports : FrameworkServerExports
{
    // 覆盖部分方法，其他使用默认实现
    public override int Spawn(edict_t* pent)
    {
        // 自定义逻辑
        Console.WriteLine("Custom spawn!");
        
        // 调用原版
        return base.Spawn(pent);
    }
}
```

### 使用框架默认

不提供自定义实现，框架自动使用 `FrameworkServerExports`，所有调用转发到原版 DLL。

## 构建产物

```
gsfdemo/
├── cl_dlls/
│   ├── client.dll              ← Loader (原生)
│   ├── libclient.dll           ← 原版 client.dll (重命名)
│   ├── GoldsrcFramework.dll    ← 核心框架
│   ├── GoldsrcFramework.Engine.dll ← 类型定义
│   ├── GoldsrcFramework.Demo.dll   ← 游戏逻辑
│   ├── GoldsrcFramework.runtimeconfig.json ← .NET 配置
│   └── ... (.NET 运行时文件)
└── dlls/
    ├── hl.dll                  ← Loader (原生)
    └── libserver.dll           ← 原版 hl.dll (重命名)
```

## 优势

1. **现代语言特性**: C# 的 LINQ、async/await、泛型等
2. **强大的工具链**: Visual Studio 调试器、IntelliSense
3. **丰富的库**: .NET 生态系统
4. **热重载**: Edit and Continue 支持
5. **类型安全**: 编译时类型检查
6. **向后兼容**: 可以调用原版 DLL 的功能

## 限制

1. **性能开销**: 托管/原生互操作有一定开销
2. **平台限制**: 当前仅支持 Windows
3. **依赖原版 DLL**: 当前实现依赖 libserver.dll/libclient.dll
4. **引擎兼容性**: 在 Xash3D 上可运行，原版 GoldSrc 引擎崩溃 (WIP)

## 未来方向

1. **完全托管实现**: 移除对原版 DLL 的依赖
2. **跨平台支持**: Linux 和 macOS
3. **Native AOT**: 提升性能，减少依赖
4. **更好的工具**: 实体编辑器、调试工具
5. **集成现代引擎**: Stride3D 等

## 总结

GoldsrcFramework 通过巧妙的分层设计和互操作技术，成功地将 20 多年前的 GoldSrc 引擎与现代 .NET 技术结合起来，为 Half-Life 模组开发带来了全新的可能性。

**核心思想**: 
- 用 C++ 加载器作为桥梁
- 用 C# 接口定义契约
- 用托管代码实现逻辑
- 保持与原版的兼容性

这种架构既保证了与引擎的兼容性，又提供了现代化的开发体验。

---

**相关文档**:
- [Architecture.md](./Architecture.md) - 详细架构文档
- [Architecture-Diagrams.md](./Architecture-Diagrams.md) - 架构图集
- [Quick-Reference.md](./Quick-Reference.md) - 快速参考

